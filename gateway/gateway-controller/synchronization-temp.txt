# Gateway Controller Multi-Instance Synchronization Plan

## Overview
Implement an event-based synchronization mechanism to support multiple Gateway Controller instances behind a load balancer. Uses a database-backed state and events architecture to ensure eventual consistency across all instances.

## Design Decisions (Based on User Input)
- **Entity Types**: APIs
- **Multi-tenancy**: No
- **Database**: SQLite + PostgreSQL support
- **Event Format**: JSON

---

## Implementation Steps

### Step 1: Database Schema Migration (v5 → v6)

**File**: `gateway/gateway-controller/pkg/storage/sqlite.go`

Add migration in `initSchema()` after version 5 check:

```sql
-- States table: tracks version for API entity type
CREATE TABLE IF NOT EXISTS entity_states (
    entity_type TEXT NOT NULL PRIMARY KEY,  -- 'API'
    version_id TEXT NOT NULL,               -- UUID updated on every change
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- API Events table
CREATE TABLE IF NOT EXISTS api_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    processed_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    originated_timestamp TIMESTAMP NOT NULL,
    action TEXT NOT NULL CHECK(action IN ('CREATE', 'UPDATE', 'DELETE')),
    entity_id TEXT NOT NULL,
    event_data TEXT NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_api_events_lookup ON api_events(processed_timestamp);
```

---

### Step 2: Create Sync Package

**New Directory**: `gateway/gateway-controller/pkg/sync/`

#### 2.1 Types (`pkg/sync/types.go`)

```go
package sync

type EntityType string
const (
    EntityTypeAPI EntityType = "API"
)

type Action string
const (
    ActionCreate Action = "CREATE"
    ActionUpdate Action = "UPDATE"
    ActionDelete Action = "DELETE"
)

type EntityState struct {
    EntityType EntityType
    VersionID  string
    UpdatedAt  time.Time
}

type Event struct {
    ID                  int64
    ProcessedTimestamp  time.Time
    OriginatedTimestamp time.Time
    Action              Action
    EntityID            string
    EventData           []byte // JSON
}
```

#### 2.2 StateManager (`pkg/sync/state_manager.go`)

Interface and implementation for managing entity_states table:
- `GetState(ctx, entityType) (*EntityState, error)`
- `UpdateState(ctx, entityType) (newVersionID string, error)`

Uses `INSERT ... ON CONFLICT DO UPDATE` for upsert.

#### 2.3 EventStore (`pkg/sync/event_store.go`)

Interface and implementations (SQLite/PostgreSQL) for events tables:
- `RecordEvent(ctx, entityType, event) error`
- `GetEventsSince(ctx, entityType, since time.Time) ([]Event, error)`
- `CleanupOldEvents(ctx, olderThan time.Time) error`

#### 2.4 SyncPoller (`pkg/sync/sync_poller.go`)

Background goroutine that:
1. Polls `entity_states` table every 5s (+ jitter up to 1s)
2. Tracks known version per entity type in memory
3. On version mismatch → fetches events since last timestamp
4. Calls registered callbacks to apply events
5. Runs hourly cleanup of events older than 24h

```go
type SyncPoller struct {
    stateManager  StateManager
    eventStore    EventStore
    callbacks     map[EntityType]SyncCallback
    lastApplied   map[EntityType]time.Time
    knownVersions map[EntityType]string
    pollInterval  time.Duration  // 5s
    jitterMax     time.Duration  // 1s
}

func (sp *SyncPoller) Start(ctx context.Context) error
func (sp *SyncPoller) Stop() error
func (sp *SyncPoller) RegisterCallback(entityType EntityType, cb SyncCallback)
```

#### 2.5 EventProcessor (`pkg/sync/event_processor.go`)

Processes events and applies to in-memory state:
- Deserializes JSON event data
- Updates ConfigStore (Add/Update/Delete)
- Triggers xDS snapshot update

---

### Step 3: Transactional Event Recording

**File**: `gateway/gateway-controller/pkg/storage/sqlite.go`

Add `GetDB()` method to expose raw `*sql.DB` for sync components:

```go
func (s *SQLiteStorage) GetDB() *sql.DB {
    return s.db
}
```

**New File**: `pkg/sync/sync_storage.go`

Create `SyncAwareStorage` wrapper that implements `storage.Storage`:

```go
type SyncAwareStorage struct {
    storage.Storage              // Embed underlying storage
    db           *sql.DB
    stateManager StateManager
    eventStore   EventStore
}

func (s *SyncAwareStorage) SaveConfig(cfg *models.StoredConfig) error {
    // 1. Begin transaction
    // 2. Call underlying SaveConfig
    // 3. Record CREATE event
    // 4. Update state version
    // 5. Commit transaction
}

// Similar for UpdateConfig, DeleteConfig
```

---

### Step 4: Configuration Changes

**File**: `gateway/gateway-controller/pkg/config/config.go`

Add to `GatewayController` struct:

```go
type SyncConfig struct {
    Enabled        bool          `koanf:"enabled"`         // default: false
    PollInterval   time.Duration `koanf:"poll_interval"`   // default: 5s
    JitterMax      time.Duration `koanf:"jitter_max"`      // default: 1s
    EventRetention time.Duration `koanf:"event_retention"` // default: 24h
}
```

**Environment Variables**:
```
GATEWAY_SYNC_ENABLED=true
GATEWAY_SYNC_POLL_INTERVAL=5s
GATEWAY_SYNC_JITTER_MAX=1s
GATEWAY_SYNC_EVENT_RETENTION=24h
```

---

### Step 5: Main.go Integration

**File**: `gateway/gateway-controller/cmd/controller/main.go`

After storage initialization (~line 95), add:

```go
var syncPoller *sync.SyncPoller
if cfg.GatewayController.Sync.Enabled && cfg.IsPersistentMode() {
    log.Info("Multi-instance synchronization enabled")

    // Get raw DB connection
    sqliteStorage := db.(*storage.SQLiteStorage)
    rawDB := sqliteStorage.GetDB()

    // Initialize sync components
    stateManager := sync.NewStateManager(rawDB, log)
    eventStore := sync.NewSQLiteEventStore(rawDB, log)

    // Wrap storage with sync-aware version
    db = sync.NewSyncAwareStorage(db, rawDB, stateManager, eventStore, log)

    // Create event processor (needs configStore, snapshotManager - set up after they're created)
    // ...
}
```

After snapshotManager initialization (~line 113), create and start poller:

```go
if syncPoller != nil {
    eventProcessor := sync.NewEventProcessor(configStore, snapshotManager, log)
    syncPoller.RegisterCallback(sync.EntityTypeAPI, eventProcessor.ProcessAPIEvents)

    if err := syncPoller.Start(context.Background()); err != nil {
        log.Fatal("Failed to start sync poller", zap.Error(err))
    }
}
```

In graceful shutdown section (~line 297), add:

```go
if syncPoller != nil {
    syncPoller.Stop()
}
```

---

### Step 6: PostgreSQL Support

**File**: `gateway/gateway-controller/pkg/sync/event_store_postgres.go`

Create PostgreSQL implementation with:
- `$1, $2` placeholder syntax instead of `?`
- `ON CONFLICT ... DO UPDATE` (same as SQLite)

**File**: `gateway/gateway-controller/pkg/sync/factory.go`

```go
func NewEventStore(dbType string, db *sql.DB, logger *zap.Logger) EventStore {
    switch dbType {
    case "postgres":
        return NewPostgresEventStore(db, logger)
    default:
        return NewSQLiteEventStore(db, logger)
    }
}
```

---

### Step 7: Testing

**Directory**: `gateway/gateway-controller/pkg/sync/` (unit tests)
**Directory**: `gateway/gateway-controller/tests/integration/` (integration tests)

1. **Unit Tests**:
   - `state_manager_test.go` - State CRUD, version updates
   - `event_store_test.go` - Event recording, retrieval, cleanup
   - `sync_poller_test.go` - Polling behavior, callback invocation

2. **Integration Tests**:
   - `sync_multi_instance_test.go` - Two instances sharing DB, verify event propagation
   - `sync_concurrency_test.go` - Concurrent writes, verify no corruption

---

## Critical Files to Modify

| File | Changes |
|------|---------|
| `gateway/gateway-controller/pkg/storage/sqlite.go` | Add v5→v6 migration, add `GetDB()` method |
| `gateway/gateway-controller/pkg/config/config.go` | Add `SyncConfig` struct |
| `gateway/gateway-controller/cmd/controller/main.go` | Initialize sync components if enabled |

## New Files to Create

| File | Purpose |
|------|---------|
| `gateway/gateway-controller/pkg/sync/types.go` | Core types (EntityType, Action, Event, EntityState) |
| `gateway/gateway-controller/pkg/sync/state_manager.go` | StateManager interface and implementation |
| `gateway/gateway-controller/pkg/sync/event_store.go` | EventStore interface and SQLite implementation |
| `gateway/gateway-controller/pkg/sync/event_store_postgres.go` | PostgreSQL EventStore implementation |
| `gateway/gateway-controller/pkg/sync/sync_poller.go` | Background polling goroutine |
| `gateway/gateway-controller/pkg/sync/event_processor.go` | Event application to in-memory state |
| `gateway/gateway-controller/pkg/sync/sync_storage.go` | SyncAwareStorage wrapper |
| `gateway/gateway-controller/pkg/sync/factory.go` | Factory for database-agnostic instantiation |

---

## Behavior Summary

1. **On API Create/Update/Delete**:
   - Record event in api_events table
   - Update version_id in entity_states table
   - Both in same transaction

2. **Background Poller (every 5s + jitter)**:
   - Read entity_states (dirty read OK)
   - Compare version_id with in-memory known version
   - On mismatch: fetch events since last timestamp, apply via callback
   - Update in-memory lastApplied timestamp and knownVersion

3. **On Startup**:
   - Load all data from main tables (not events)
   - Initialize knownVersions from entity_states
   - Start polling from current timestamp

4. **Cleanup**:
   - Hourly job deletes events older than 24h
